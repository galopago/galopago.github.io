var store = [{
        "title": "Nodo LoRa basado en RAK811 y alimentado por baterias AA",
        "excerpt":"Nodo LoRa concebido para la experimentacion. Se conecta facilmente con casi cualquier tipo de sensor. Dise√±ado para instalarse dentro de una caja generica resistente al agua, solo hay que agregar un par de pilas AA alcalinas, y listo para usarse!   Componente clave: Modulo LoRa RAK811.    \t   \tNodo Lora dentro de la caja resistente agua.   Principales caracteristicas:     Hardware &amp; Software de Codigo Libre   Se alimenta con 2 pilas AA (1.5v) .   Resistente al agua y montable en pared.   RAK811=SX1276+STM32L151. No se necesita microcontrolador adicional.   Programacion mediante RAK RUI API, o STM32 CUBE LoRa stack.   Area para expansion y/o Prototipado.   Pads para soldar antena de resorte interna o conector U.FL para externa.   Listado de materiales                  Componente       Consigue el tuyo!       Hoja de caracteristicas                       Modulo LoRa RAK811       üí∏       RAK811.pdf                 Caja generica resistente al agua de 83x58x33mm  (varias opciones: tapa transparente, salientes para montaje en pared)       üí∏       AK10019-A1.pdf                 Tornillo autorroscante M2.6  tipo B       üí∏       M2.6x5-6-8-12mm.pdf                 Soporte para bateria AA para montaje en PCB       üí∏       BH311.pdf                 Bornera de tornillo kf350 3.5mm 3 pines       üí∏       KF350.pdf                 Antena de resorte para 433,868,915 MHz       üí∏       SW433-TH32.pdf SW868-TH06.pdf SW915-TH12.pdf                 Conector de hilera de pines hembra 2.54mm       üí∏       FHA3-SXX.pdf                 Conector de hilera de pines macho 2.54mm       üí∏       PHA1-S3XX.pdf           Tarjetas de Circuito Impreso                  PCB       Archivos fuente                       Tarjeta principal       RAK811 LORA ADAPTABLE NODE                 Tarjeta de expansion       RAK LORA ADAPTABLE NODE BREAKOUT 2AA           Software                  Software       Archivos fuentes                       Firmware       RAK811 RUI SWITCH SENSOR           Personalizacion  El proyecto ha sido dividido en 4 principales aspectos: fuente de alimentacion, caja, antena y expansion. Cada uno de los cuales puede ser modificado segun los requerimientos propios. Finalmente se presentara una aplicacion de ejemplo para mostrar como implementar su propio sensor.   Fuente de alimentacion  El dispositivo puede operar desde 1.8v hasta 3.7v. Hay varias alternativas para hacerlo:     2 Pilas alcalinas AA. Se deberan cortocircuitar las posiciones 1-2 del jumper JP1.   1 Pila de litio 14500. Se deberan cortocircuitar las posiciones 2-3 del jumper JP1. El soporte para la bateria BT2 puede ser removido, liberando un poco de espacio en el PCB.   Fuente de alimentacion externa en la bornera J1. Los soportes para baterias BT1 y BT2 pueden ser removidos, liberando aun mas espacio en el PCB.   Caja  El PCB tiene las dimensiones correctas para ser instalado dentro de una caja plastica ‚Äúgenerica‚Äù a prueba de agua de 83x58x33mm . Estas cajas vienen en multiples variantes: gris, negro, blanco, tapa transparente, salientes para montaje en pared, etc. La tarjeta se fija a la caja mediante 2 tornillos autorroscantes.   Expansion    \t   \t   \tArea para expansion y/o prototipado.   El area de prototipado contiene pads para soldadura que estan conectados a todos los pines del modulo RAK811, adicionalmente hay algunos pads libres para realizar algo de prototipado mediante cable y soldadura. Las conexiones a sensores externos se realizan mediante las borneras W, X, Y, Z. En caso que la inmensa area para prototipado no sea suficiente, se pueden soldar regletas de conectores hembra para agregar una tarjeta de expansion desmontable. Notese que el RAK811-LF y RAK811-HF tienen algunas diferencias en unos cuantos pines de i/o.   Opciones de antena  Antena interna de resorte soldada en el pad J6, se deberan cortocircuitar las posiciones 1-2 del jumper JP2.   Antena externa usando conector U.FL, se deberan cortocircuitar las posiciones 2-3 del jumper JP2.   Aprovisionamiento  Como el codigo es derivado de un producto existente de RAK Wireless, se usan los mismos comandos  AT para el aprovisionamiento del nodo en la red LoRa usando la UART. Para mayor informacion ver el  manual que contiene los comandos completos AT.   Aplicacion de ejemplo    \t   \t   \t   \tNodo LoRa interruptor magnetico.   La aplicacion de ejemplo consiste en un interruptor magnetico LoRa que transmite un paquete cada vez que se cierra o se abre el contacto debido al efecto de acercar o alejar el iman. Para ello se instalo un reed switch peque√±o en una de las paredes al interior de la caja. La tarjeta de expansion es usada para instalar los componentes suplementarios: Led indicador de transmision, resistencias de pullup, pulsador para  prueba de transmision, y divisor de voltaje para monitoreo de bateria.   Cualquier otro sensor de tipo interruptor (sensor de inclinacion por esferas, resorte detector de vibracion, etc.) puede ser agregado!   Para hacer las conexiones se uso cable con recubrimiento PVDF por su alta resistencia al calor, en especial al soldar con cautin!.  Para mas informacion sobre el PCB o el  firmware, recuerde consultar los repositorios vinculados   Componentes opcionales:                  Componente       Consigue el tuyo!       Hoja de caracteristicas                       Alambre 30 AWG con recubrimiento PVDF UL1423       üí∏       UL1423.pdf                 Conector para antena externa U.FL montaje superficial       üí∏       6474011114.pdf                 Reed switch plastico peque√±o       üí∏       GPS-11A.pdf                 Iman para fijacion en pared mediante tornillos       üí∏       MC-38.pdf                 Sensor de vibracion tipo resorte       üí∏       SW-18015p.pdf                 Sensor de inclinacion por esferas       üí∏       SW-200D.pdf                 Resistencias TH 1/4W 1%       üí∏       MGR-SERIES.pdf                 Led 3mm       üí∏       1254-10SYGD.pdf                 Interruptor momentaneo pulsador  6x6mm       üí∏       TS-1301.pdf           ","categories": ["espanol"],
        "tags": ["AN000","LoRaWAN"],
        "url": "https://galopago.github.io/espanol/nodo-lora-rak811-aa/",
        "teaser": "https://galopago.github.io/assets/images/RAK811_NODE_OPEN_TEASER.jpg"
      },{
        "title": "RAK811 based LoRa Node powered by AA batteries",
        "excerpt":"LoRa node conceived for experimentation. Easy to interface to multiple kind of sensors. Designed to fit inside a generic waterproof enclosure, just add a pair of AA alkaline batteries and deploy!   Core component: RAK811 LoRa module.    \t   \tLora Node inside waterproof case   Key features:     Open source Hardware &amp; Software   Powered by 2xAA (1.5v) batteries.   Waterproof &amp; wall mountable.   RAK811=SX1276+STM32L151. No additional ŒºC needed.   Build environment: RAK RUI API, or STM32 CUBE LoRa stack.   Prototyping/expansion area.   Pad for a spring antenna or U.FL connector for external ant.   Bill Of Materials                  Component       Get yours!       Datasheet                       RAK811 LoRa Module       üí∏       RAK811.pdf                 Generic 83x58x33mm waterproof enclosure box (wall mounting tabs, clear cover options available)       üí∏       AK10019-A1.pdf                 M2.6 self-tapping B-type screw       üí∏       M2.6x5-6-8-12mm.pdf                 Single AA battery holder for PCB mounting       üí∏       BH311.pdf                 Screw terminal kf350 3.5mm 3 pin       üí∏       KF350.pdf                 Spring antenna for 433,868,915 MHz       üí∏       SW433-TH32.pdf SW868-TH06.pdf SW915-TH12.pdf                 Female header 2.54mm       üí∏       FHA3-SXX.pdf                 Male pin header 2.54mm       üí∏       PHA1-S3XX.pdf           Printed Circuit Boards                  PCB       Source files                       Main circuit board       RAK811 LORA ADAPTABLE NODE                 Breakout/expansion       RAK LORA ADAPTABLE NODE BREAKOUT 2AA           Software                  Software       Source files                       Firmware       RAK811 RUI SWITCH SENSOR           Customization  The project is divided in four main aspects: power source, enclosure, antenna and expansion which can be modified for the exact requirements. Finally a sample application is given as a way to show how to implement your own sensor solution.   Power source  The device can work from 1.8v up to 3.7v. There are many alternatives to power it:     2 x AA alkaline batteries. JP1 jumper positions 1-2 shorted.   1 x 14500 lithium battery. JP1 jumper positions 2-3 shorted. The BT2 battery holder could be removed, freeing up some PCB space.   External power applied to J1 screw terminal. BT1 and BT2 battery holders could be removed, freeing up even more PCB space.   Enclosure  The PCB fits inside a ‚Äúgeneric‚Äù unbranded 83x58x33mm waterproof plastic enclosure. These enclosures came in multiple flavors: gray, white, black, clear lid, wall mounting tabs. The board is fixed to the enclosure by two self tapping screws.   Expansion    \t   \t   \tPCB expansion area   The prototyping area contains through hole soldering pads routed to all pins of RAK811 module, plus  some small amount of free connected pads for prototyping. Connections for outside detachable sensors are provided via W,X,Y,Z screw terminals. If the vast prototyping area isn‚Äôt enough, female pin headers could be soldered and an expansion board could be plugged in. Notice that RAK811-LF and RAK811-HF have slighter differences in some i/o pins   Antenna options  Internal spring antena soldered on J6, JP2  jumper positions 1-2 shorted.  External antenna using U.FL. connector, JP2 jumper positions 2-3 shorted.   Provisioning  As the code was derived from a RAK Wireless existing product, it uses de same AT commands for provisioning using UART. Here is the  manual with the complete AT commands.   Sample application    \t   \t   \t   \tMagnetic Switch LoRa sensor node   The sample applications consist in a LoRa magnetic switch sensor which transmits a packet when the switch opens or closes. A very small reed switch is installed in one of the walls inside enclosure. Breakout board  was used to install the supplementary electronic components: Led indicator, pullup resistors, test button, and voltage divider for battery monitoring.   Any other kind of switch sensor (ball inclination sensor, spring vibration sensor, etc.) could be added!   PVDF wire was used to make connections because the insulation resists pretty well soldering iron abuse!.  For more information about the PCB or the firmware, don‚Äôt forget to read the linked repositories.   Optional components:                  Component       Get yours!       Datasheet                       30 AWG wire wrap UL1423 PVDF cable       üí∏       UL1423.pdf                 U.FL smd external antenna conector       üí∏       6474011114.pdf                 Plastic small reed switch       üí∏       GPS-11A.pdf                 Magnet with screw tabs for wall mounting       üí∏       MC-38.pdf                 Vibration spring sensor       üí∏       SW-18015p.pdf                 Tilt ball sensor       üí∏       SW-200D.pdf                 1/4W 1%  TH Resistors       üí∏       MGR-SERIES.pdf                 3mm led       üí∏       1254-10SYGD.pdf                 Push button  6x6mm       üí∏       TS-1301.pdf           ","categories": ["english"],
        "tags": ["AN000","LoRaWAN"],
        "url": "https://galopago.github.io/english/rak811-lora-node-aa/",
        "teaser": "https://galopago.github.io/assets/images/RAK811_NODE_OPEN_TEASER.jpg"
      },{
        "title": "WiFi controlled waterproof LED string",
        "excerpt":"Decorative lights suitable for Halloween, Christmas, parties, etc. Not only controlled over internet but, also completely reprogrammed  wirelessly using OTA over WiFi. Waterproof, dustproof and sturdy. Ideal for indoor projects like interactive backgrounds for youtubers/streamers controlled by their audience and for outdoor projects like advertizing signs in walls or vehicles.    \t   \tOpen enclosure showing internal components   Key component: WS2811 waterproof LED string.   Concept:   With the advent of addressable LED like WS2812, WS2812b, WS2811, etc. is now possible for small microcontrollers to  handle large amounts of LEDs with only one I/O pin. That advantage popularized this component and a lot of variants appeared: surface mount  single leds, flexible strips, Christmas-like strings, etc. The last one will be used in this article due to its flexibility and strength and could adapt easily to different project from Christmas ornaments to led matrix, without soldering or other electrical modifications.   The microcontroller chosen was an ESP8266, more exactly a development board known as ‚ÄúNODEMCU V3‚Äù which has all additional components necessary to start work on programming the MCU with a computer. The onboard WiFi of the ESP8266 is not only possible to to change light sequences, but also download a totally different firmware wirelessly (OTA), using a powerful combo: Mongoose OS and its remote device management dashboard mDASH. Mongoose OS uses a scaled down version of JavaScript known as mJS. This is an attractive language for web developers whom already  work with JS. Mongoose OS is built on top of Espressif‚Äôs ESP-iDF, so it is possible to write functions in C, which is also attractive for more ‚Äútraditional‚Äù embedded programmers.   The circuit is built using TUSISTEMITA hardware prototyping system, which provides different kinds of prebuilt modules which allows to build an electronic project without soldering, but making it very robust and expandable. All the parts are enclosed in a dustproof and waterproof IP65 box. This enclosure gives an ‚Äúindustrial look‚Äù to the project and also adds mechanical strength to withstand abuses. The external electrical connections (AC, and LEDs) were fitted with IP accessories to provide a good seal.   Key features:     Mongoose OS embedded operating system running on ESP8266.   Dustproof, waterproof and wall mountable.   Wireless remote firmware update, thanks to Mongoose OS management dashboard mDASH.   Built with TUSISTEMITA hardware prototyping blocks   110/220V AC power   The circuit is composed of 4 elements well differentiated: Power source, CPU, logic level shifter and LEDs. Power source is switched type, 20W power, 5V output and 110/220V input, so it could be used in any country of the world. ESP8266 was used as CPU (NODEMCU V3). This board can be powered by 3.3V directly to processor power pin or by 5V using the onboard regulator. The high logic level output of ESP8266 is 3.3V, so a logic level shifter is needed for working with 5V sensors. WS2812 works with 5V logic levels so TUSISTEMITA D06 logic level board converter was used. This board is based on BSS138 MOSFET.    \t   \tSimplified block diagram   Power source output current is around 3.8A max, and each WS2811 LED consumes 60 mA max, so at least 63 LED could be powered. To stay below absolute maximum only 50 LED is recommended. Any LED string that works with WS2811 compatible protocol could be used.   Mongoose OS:   Mongoose OS is an operating system for the Internet Of Things, it can run on ESP8266, ESP32 and others. Is a blend of easiness and robustness. Ideal for rapid prototyping of IoT products because of its native built-in cloud connectivity (AWS, Google, Azure). There are two characteristics that make Mongoose OS so versatile. One of them is the possibility to work ‚Äúremote/local‚Äù. Remote is the default option, and compiles the code in the cloud, this is good for beginners because avoids the problems related to SDK installations. Local option is based on docker containers and is good for automatic builds without internet connection.   Another important characteristic is the use of a scaled down version of JavaScript called mJS as programming language. Advanced functionalities could be written with few lines of code compared to other languages (Assembler, C, Processing). However, nothing prevents to call functions written in C, especially for time sensitive device drivers.   Software:   Sample application presented here is composed of two tasks: Send color data for every LED in the string and listen to incoming data coming from the cloud.   To send data to each LED, the color code is randomly extracted from a predefined color table. Communication to the LED string is made using NEOPIXEL library bundled  with Mongoose OS.   An MQTT connection is established to a broker where the app subscribes to a specific topic. A third party client application must connect to the same MQTT broker and publish data to the same topic to change the color palette used. This is a very simple way to change the light pattern over the internet.   Circuit assembly:   The circuit was built using components of TUSISTEMITA, like enclosure backplate, power source backplate, NODEMCU breakboard, logic level shifter board and screw  terminal board. Once the app is downloaded for the first time, and electrical connections verified, the backplate could be attached to the enclosure hassle free. Just unplug external cables from terminals, screw backplate to enclosure and reconnect cables again.    \t   \t   \t   \tAssembly and wiring.   It is recommended to change the connectors of the LED strip, for a more robust and waterproof connectors. Heatshrink tube with glue (double wall) should  be used to protect solder joints from the elements.    \t   \t   \t   \tCable glands and waterproof connectors   Once the enclosure is closed, firmware updates could be done via wirelessly via OTA, using Mongoose OS device management dashboard mDASH.   Bill of materials                  Component       Get yours!       Datasheet                       ESP8266 NodeMCU V3       üí∏       NodeMCUV3.pdf                 WS2811 waterproof LED string       üí∏       WS2811_WATERPROOF_LED_STRING.pdf                 Switched power supply 5V 3.8A 20W       üí∏       5V_4A_switching_power.pdf                 Waterproof plastic enclosure 200x120x75mm (multiple options: transparent lid, wall mounting tabs)       üí∏       g373_g269.pdf                 M2.6 self-tapping B type screw       üí∏       M2.6x5-6-8-12mm.pdf                 M3 countersunk phillips screw       üí∏       M2-M10_Stainless_steel_304_countersunk_screw_flat_head_phillips.pdf                 M3 hex flanged nut DIN6923       üí∏       FLANGED_NUT_3MM_DIN6923.pdf                 Nylon spacer G228       üí∏       G228.pdf                 Cable gland PG7 or PG9       üí∏       pg_7.pdf                 3 pin waterproof cable connector for LED string       üí∏       Waterproof_led_string_connector.pdf                 3:1 Heatshrink tube with glue       üí∏       3_1_heatshrink_tube_glue.pdf                 2:1 Heatshrink tube multiple colors       üí∏       2_1_heatshrink_tube_colors.pdf           TUSISTEMITA blocks                  PCB       Source file                       A02 Backplate for 200x120x75mm enclosure       A02                 A05 adapterboard 10.16mm pitch for 5V 3.8A PSU       A05                 B01 2x4 3.5mm screw terminal board       B01                 C08 screw terminal breakout board for NODEMCU V3       C08                 D06 logic level shifter board       D06           Software                  Software       Source file                       Firmware       MOS_IOT_ADDRESSABLE_LEDS           Optional Components:                  Component       Get yours!       Datasheet                       3 pc step drill bit 3-20 mm + centerpunch       üí∏       3_pc_set_3-20mm_drill_bit_incremental_center_punch.pdf                 8 Step drill bit 10-45 mm       üí∏       8_steps_10-45mm_incremental_drill_bit.pdf          ","categories": ["english"],
        "tags": ["AN001","WiFi","MONGOOSE OS"],
        "url": "https://galopago.github.io/english/WiFi-waterproof-led-string/",
        "teaser": "https://galopago.github.io/assets/images/MOS_WIFI_IOT_LIGHTS_TEASER.jpg"
      },{
        "title": "Tira de luces LED resistentes al agua controladas por WiFi",
        "excerpt":"Luces apropiadas para decoraciones navide√±as, halloween, etc. No solamente la secuencia puede ser manejadas por internet, sino que tambien se pueden reprogramar completamente de forma inalambrica (OTA) mediante una conexion WiFi. Construccion robusta  a prueba de polvo y agua. Ideal para montajes en interiores: como fondo para transmisiones de youtubers/streamers  (manejadas en tiempo real por su audiencia), exteriores fijos como muros y avisos, o en exteriores moviles como carrozas de carnaval.    \t   \tCaja de las luces destapada mostrando sus componentes internos   Componente clave: Tira de LED WS2811 a prueba de agua.   El concepto:   Con la llegada de los LED direccionables como el WS2812, WS2812b, WS2811, etc. fue posible controlar individualmente grandes cantidades de leds usando un solo pin de microcontrolador!. Dicha facilidad de uso contribuyo a popularizar estos componentes y a que estos se vendieran en diferentes presentaciones: leds individuales para montaje superficial, series de luces en tiras flexibles, extensiones de luces tipo ‚Äúarbol de navidad‚Äù a prueba de agua, entre otras. Es precisamente estas ultimas las que seran usadas en este proyecto dado lo facil que pueden adaptarse a distintos tipos de proyectos como matrices de leds hasta adornos navide√±os, sin tener que soldar ni hacer modificaciones electricas a las luces.   Como microcontrolador se uso un ESP8266, mas precisamente una tarjeta conocida como ‚ÄúNODEMCU V3‚Äù que incorpora ya todos los elementos adicionales para poder realizar la programacion inicial desde un computador. Utilizando el WiFi incorporado del ESP8266, no solo es posible controlar las secuencias y colores de las luces desde internet, sino que tambien es posible descargarle nuevos programas de forma remota (OTA) usando un combo poderoso: El sistema operativo Mongoose OS junto con plataforma para gestion remota de dispositivos mDASH. Mongoose OS usa una version restringida de JavaScript conocida como mJS, lo que probablemente resultara atractivo para programadores web que ya trabajan con este tipo de tecnologia. Mongoose OS esta construido sobre el ESP-IDF de Espressif, por lo tanto pueden hacerse llamados a funciones escritas en C, lo que sin duda tambien resultara atractivo para programadores de microcontroladores ‚Äútradicionales‚Äù que han trabajado con este lenguaje bastante maduro.   En cuanto al montaje fisico, se utilizo el sistema de prototipado de hardware TUSISTEMITA que proporciona una serie de  modulos y elementos preconstruido que permiten realizar un proyecto electonico sin necesidad de soldaduras, haciendolo facilmente modificable y flexible, pero a la vez robusto. Todo el conjunto va dentro de una caja a prueba de agua IP65, la cual le proporciona resistencia al polvo y al agua, ademas de darle un aspecto estetico ‚Äúindustrial‚Äù  tambien le otorga suficiente robustez mecanica para soportar uno que otro abuso. Los cables de conexiones electricas externas de la caja, fueron complementadas con accesorios para garantizar el sellamiento IP65.   Principales Caracteristicas:     Sistema Operativo embebido Mongoose OS corriendo sobre ESP8266   Resistente al agua y con pesta√±a para montaje en pared.   Actualizacion remota del Firmware gracias a la plataforma de gestion Mongoose OS dashboard mDASH   Montaje realizado mediante el sistema de prototipado robusto para hardware electronico TUSISTEMITA   Alimentacion 110/220V AC.   El hardware esta compuesto por 4 elementos bien diferenciados: Fuente de alimentacion, CPU, adaptador de nivel logico y LEDS. La fuente de alimentacion es de tipo comutada con 20W de potencia, 5 voltios de salida y entrada de 110V a 220V, por lo tanto puede ser usada practicamente en cualquier lugar del mundo. Como CPU se uso un ESP8266 en una tarjeta NODEMCU V3. Esta tarjeta puede ser alimentada a 3.3V directamente al pin de alimentacion del procesador, o por 5V haciendo uso del regulador incorporado. Las salidas logicas de la CPU tendran voltajes de 0 a 3.3V, lo que debera ser tenido en cuenta si se desea instalar sensores u otros perifericos que trabajen a 5V. Es aqui donde entre cobra importancia el adaptador de nivel logico, pues los leds son alimentados a 5V y esperan una se√±al logica con esta misma amplitud. Como adaptador de nivel logico se uso la tarjeta TUSISTEMITA D06 que internamente usa un MOSFET BSS138 para realizar dicho trabajo.    \t   \tDiagrama simplificado de bloques   La fuente de poder entrega aproximadamente 3.8 A y cada led WS2811 consume 60 mA como maximo, estando en capacidad de alimentar extensiones de hasta 63 leds. Para tener cierto margen se ha decidido usar extensiones de maximo 50 leds. Cualquier tipo de tira de LED que use el mismo protocolo del WS2811 puede ser usada.   Que es Mongoose OS?:  Mongoose OS es un sistema operativo para Internet De las Cosas, compatible con ESP8266, ESP32 entre otros. Combina facilidad con robustez. Es ideal para el prototipado rapido de productos IoT, pues trae incorporada la conectividad nativa con ‚Äúnubes‚Äù publicas o privadas como AWS, Google, Azure, etc. Hay dos caracteristicas muy importantes que lo hacen tan versatil. Una de ella es la posibilidad de usarlo ‚Äúremoto/local‚Äù. Remoto, que es la opcion por defecto, la compilacion se realiza en la nube lo cual evita los problemas clasicos de instalacion de los SDK para desarrollo embebido.  Tambien existe la posibilidad de instalarlo localmente mediante dockers, en cuyo caso se puede compilar sin tener una conexion a internet.   La otra caracteristica importante, es que usa como lenguaje de programacion un subconjuto de JavaScript llamado mJS (embedded javascript). Esto hace que se  puedan crear muchas funcionalidades avanzadas, sin necesidad de escribir tanto codigo como en otros lenguajes usados en sistemas embebidos (Assembler, C, Processing). Sin embargo nada impide que se puedan llamar funciones escritas en C puro para ganar desempe√±o, en especial al escribir controladores para sensores y perifericos que requieren un manejo eficiente de los recursos.   El programa:   El firmware presentado en este proyecto realiza dos tareas: Encender cada uno de los leds con un color determinado y la otra se encarga de recibir datos desde la nube.   Para enviar el dato de color a cada uno de los LED , este se extrae aleatoriamente de una tabla de colores predefinida. La comunicacion con los LED se realiza mediante la biblioteca NEOPIXEL que incorpora Mongoose OS.   Para recibir los datos desde la nube, se realiza una conexion MQTT a un broker donde se escucha por un topico especifico. Una aplicacion cliente puede conectarse a este broker MQTT y enviar un determinado dato al topico que se esta escuchando, y con esto se puede cambiar la paleta de colores que se esta usando para los LED. De esta forma se presenta una aplicacion de ejemplo muy simple de como modificar la secuencia de forma remota a traves de internet.   Ensamblaje:   El prototipo del sistema fue montado usando varios componentes de TUSISTEMITA, como la placa trasera para montaje, las tarjetas adaptadoras para la fuente y NODEMCU, tarjeta de  conversion niveles logicos y borneras de tornillos para conexiones de salida. Una vez descargada la aplicacion por primera vez y comprobado que las conexiones electricas funcionan bien, se puede pasar a la caja para montaje definitivo sin ningun traumatismo. Solamente hay que desconectar la alimentacion electrica de las borneras y la conexion de salida a los leds, ajustar la placa a la caja y reconectar nuevamente.    \t   \t   \t   \tEnsamblaje y cableado.   Se recomienda cambiar los conectores originales de las tiras de led, por unos mucho mas robustos mecanicamente y a prueba de agua, para evitar problemas de oxido en caso de estar expuestos a los elementos ambientales. Se aconseja el uso de termoencogible con pegamento para mayor proteccion en las uniones entre los cables de la tira led y los conectores.    \t   \t   \t   \tConectores para proteccion de los cables   Una vez la caja se encuentra cerrada, las actualizaciones de firmware se pueden hacer inalambricamente mediante OTA por medio del dashboard de Mongoose OS mDash.   Listado de materiales                  Componente       Consigue el tuyo!       Hoja de caracteristicas                       ESP8266 NodeMCU V3       üí∏       NodeMCUV3.pdf                 Tira de LED WS2811 resistente al agua       üí∏       WS2811_WATERPROOF_LED_STRING.pdf                 Fuente de alimentacion conmutada 5V 3.8A 20W       üí∏       5V_4A_switching_power.pdf                 Caja estanca generica resistente al agua de 200x120x75mm (varias opciones: tapa transparente, salientes para montaje en pared)       üí∏       g373_g269.pdf                 Tornillo M2.6 autorroscante tipo B       üí∏       M2.6x5-6-8-12mm.pdf                 Tornillo M3 cabeza avellanada en cruz       üí∏       M2-M10_Stainless_steel_304_countersunk_screw_flat_head_phillips.pdf                 Tuerca M3 hexagonal con brida DIN6923       üí∏       FLANGED_NUT_3MM_DIN6923.pdf                 Espaciador separador de nylon G228       üí∏       G228.pdf                 Conector glandula o prensa estopa PG7 o PG9       üí∏       pg_7.pdf                 Conector resistente al agua para tira led       üí∏       Waterproof_led_string_connector.pdf                 Tubo termoencogible 3:1 con pegamento       üí∏       3_1_heatshrink_tube_glue.pdf                 Tubo termoencogible 2:1 multiples colores       üí∏       2_1_heatshrink_tube_colors.pdf           Componentes TUSISTEMITA                  PCB       Archivos fuente                       Placa trasera para montaje A02 para caja de 200x120x75mm       A02                 Placa adaptadora A05 con agujeros espaciados 10.16mm para fuente 5V 3.8A       A05                 Tarjeta B01 para conexiones mediante terminales de tornillos 2x4 3.5mm       B01                 Tarjeta breakout C08 con salida a terminales de tornillos para NODEMCU V3       C08                 Tarjeta D06 de conversion de niveles logicos       D06           Software                  Software       Archivos fuente                       Firmware       MOS_IOT_ADDRESSABLE_LEDS           Componentes opcionales:                  Componente       Consigue el tuyo!       Hoja de caracteristicas                       Juego de 3 brocas escalonadas 3-20 mm + centropunto       üí∏       3_pc_set_3-20mm_drill_bit_incremental_center_punch.pdf                 Broca escalonada de 8 pasos 10-45 mm       üí∏       8_steps_10-45mm_incremental_drill_bit.pdf          ","categories": ["espanol"],
        "tags": ["AN001","WiFi","MONGOOSE OS"],
        "url": "https://galopago.github.io/espanol/tira-luces-led-resistentes-agua-wifi/",
        "teaser": "https://galopago.github.io/assets/images/MOS_WIFI_IOT_LIGHTS_TEASER.jpg"
      },{
        "title": "Pedal USB basado en Rpi Pico",
        "excerpt":"Pedal USB (o cualquier otro interruptor momentaneo) que emula la pulsacion de teclas o combinaciones de teclas. Util para usar con aplicaciones de edicion de video para detener/reproducir sin tener que quitar las manos del teclado ni del raton, tambien puede usarse con aplicaciones de videoconferencia para hacer mute rapidamente. No se requiere ninguna aplicacion especial para descargar el firmware inicial, ni tampoco para configurar las teclas (un simple editor de texto bastara). Funciona practicamente con cualquier sistema operativo, incluso con dispositivos Android usando un adaptador USB OTG.    \t   \tPedal USB instalado en una caja robusta   Componente clave: Rpi Pico.   El concepto:   La gran mayoria de los pedales programables USB que se encuentran en el mercado poseen la gran desventaja de requerir instalar una aplicacion para poder ser configurados. Esta aplicacion la mayoria de las veces solo funciona en Windows y generalmente viene traducida a muy pocos idiomas(a veces no viene traducida!). Esto supone que para usuarios de Linux o Mac, se requiera instalar una maquina virtual para poder configurar dicho pedal, o pedir el favor a algun usuario de windows que nos ayude con esta tarea.   Es aqui donde cobra importancia el Raspberry Pi Pico, por 2 grandes razones: Tiene interfaz nativa USB, por lo que no se requiere de programador ni hardware adicional para descargar los programas y la mas importante aun es que soporta CircuitPython, por lo que se puede programar ‚Äúen caliente‚Äù sin necesidad de estar permanentemente compilando y descargando firmware durante el proceso de depuracion. ¬°Por lo tanto es el candidato perfecto para hacer nuestro propio pedal!   Otra ventaja adicional con respecto a los pedales USB comerciales, es que el propio pedal, puede ser reemplazado facilmente por uno de mejor calidad o resistencia, pero conservando el circuito original. Tambien podria usarse otro tipo de interruptores diferentes para ser activados con partes del cuerpo diferentes a los pies. ¬°La cantidad de interruptores que se le pueden adicionar solo esta determinada por los GPIO disponibles del Rpi Pico y por el tama√±o de la caja!   En cuanto al montaje fisico, se utilizo el sistema de prototipado de hardware TUSISTEMITA que proporciona una serie de  modulos y elementos pre construidos que permiten realizar un proyecto electronico sin necesidad de soldaduras, haciendolo facilmente modificable y flexible, pero a la vez robusto. Todo el conjunto va dentro de una caja a prueba de agua IP65, la cual le proporciona resistencia al polvo y al agua. Dicha caja ademas de proporcionarle un aspecto estetico ‚Äúindustrial‚Äù  tambien le otorga suficiente robustez mecanica para soportar uno que otro abuso. Los cables de conexiones electricas externas de la caja, fueron complementadas con accesorios para garantizar el sellamiento IP65.   Principales Caracteristicas:      Desarrollado mediante CircuitPython, amigable y facil de entender   Compatible con los sistemas operativos mas conocidos   No se requiere instalar ninguna aplicacion para descargar el Firmware inicial   La configuracion de las teclas se realiza mediante la edicion de un archivo de texto   Resistente al agua y golpes.   Pedales reemplazables   Montaje realizado mediante el sistema de prototipado robusto para hardware electronico TUSISTEMITA   Alimentacion mediante puerto USB, no requiere fuente adicional.   El hardware es bastante simple, solo se requiere el Rpi Pico y los interruptores conectados cada uno a un GPIO y a tierra. Se usan las resistencias de pull-up internas. La alimentacion y los datos llegan por el conector USB    \t   \tDiagrama simplificado de bloques   Que es CircuitPython?:  Dicho en palabras de Industrias Adafruit, creadores de CircuitPython:     es un lenguaje de programacioÃÅn dise√±ado para simplificar la experimentacion y aprendizaje de programar en microcontroladores de bajo costo. Hace el iniciar mas sencillo que nunca sin necesidad previa de descargar herramientas a la estacioÃÅn de trabajo. Una vez que tu tarjeta ha sido preparada, abres cualquier editor de texto, y puedes comenzar a escribir codigo. Es asi de simple.    Otras razones para usar CircuitPython incluyen:      Quieres tener tu ambiente listo para trabajar, en poco tiempo. Creas un archivo, editas tu codigo, salvas el archivo y se ejecuta de inmediato. No hay proceso de compilado, sin descargas ni subidas necesarias.   Eres nuevo en programacion. CircuitPython es dise√±ado pensando en educacion. Es sencillo comenzar a programar, y recibes retroalimentacion inmediata de la tarjeta.   Actualiza sencillamente tu codigo. Dado que tu codigo vive en la unidad de disco, puedes editarlo cuando gustes, y puedes mantener varios archivos con diferentes archivos para facil experimentacion.   La consola serial y REPL. Estas te permiten recibir retroalimentacion en vivo de tu codigo y programando de forma interactiva.   Almacenamiento de archivos. El almacenamiento interno de CircuitPython es un excelente lugar para bitacoras de datos, tocar archivos de audio o para interactuar con archivos.   Fuertes capacidades de hardware. Hay muchas bibliotecas y controladores para sensores, tarjetas especificas y otros componentes externos.   El programa:   El firmware presentado en este proyecto realiza dos tareas: Inicializar los GPIO dependiendo del archivo de configuracion y luego de esto un ciclo infinito estara verificando la pulsacion de cada interruptor para enviar el respectivo codigo de tecla. Se ha hecho uso de un antirebote por software para evitar falsas pulsaciones. Cada vez que se activa cualquiera de las entradas, se encendera el led incorporado en la tarjeta Rpi Pico   El archivo de configuracion tiene una estructura muy simple, en donde esta escrito cuales son los GPIO a usar, que codigo de tecla enviara cuando dicho GPIO se active y adicionalmente que modificador de tecla se usara (por ejemplo SHIFT, CONTROL, ALT). En caso de no encontrarse el archivo de configuracion, el programa asumira unos valores por defecto. En dicho archivo no solo se puede modificar las teclas que se envian, sino que se pueden agregar tantos GPIO como se quiera, de esta forma se podrian tener 3 o 4 pedales.   Ensamblaje:   El prototipo del sistema fue montado usando varios componentes de TUSISTEMITA, como la placa trasera para montaje, y la tarjeta de salida a terminales de tornillo para el Rpi Pico   Una vez descargada la aplicacion por primera vez y comprobado que las conexiones electricas funcionan bien, se puede pasar a la caja para montaje definitivo sin ningun traumatismo. Solamente hay que desconectar el puerto USB y las terminales de tornillo donde estan conectados los interruptores de prueba, fijar la placa a la caja y reconectar nuevamente.    \t   \t   \t   \tPruebas, ensamblaje y cableado.   Se escogio un conector USB tipo impresora, por ser uno de los mas robustos e intuitivos. El conector usado es del tipo para montaje en panel y tiene 4 pines para soldar los cables (VCC,USB+,USB-,GND). Este conector se soldo a una extension Micro USB que conectara al Rpi Pico. Los pedales usan conectores tipo aviacion    \t   \t   \t   \tConectores para pedales y computador   Una vez cerrada la caja, las actualizaciones al programa pueden hacerse modificando el archivo de CircuitPython, o usando la interfaz interactiva. Si se requiere hacer una reinstalacion de CircuitPython o ‚Äúformatear‚Äù el Rpi Pico, debera abrirse la caja para tener acceso al boton bootsel.   Listado de materiales                  Componente       Consigue el tuyo!       Hoja de caracteristicas                       Tornillo M2.6 autorroscante tipo B       üí∏       M2.6x5-6-8-12mm.pdf                 Espaciador separador de nylon G228       üí∏       G228.pdf                 Tubo termoencogible 2:1 multiples colores       üí∏       2_1_heatshrink_tube_colors.pdf                 Caja estanca generica resistente al agua de 115x90x55 mm       üí∏       KH-F2.pdf                 Raspberry Pi Pico       üí∏       pico-datasheet.pdf                 Conector USB Tipo B IP68 para panel       üí∏       USB_TYPE_B_PANEL_MOUNT_CONNECTOR.pdf                 Conector de aviacion 4 pines       üí∏       CIRCULAR_AVIATION_PANEL_CONNECTOR.pdf                 Interruptor momentaneo de pedal Metalico       üí∏       METAL_MOMENTARY_ELECTRIC_FOOT_SWITCH.pdf                 Cable de impresora USB tipo A       üí∏       USB_PRINTER_CABLE.pdf                 Cable Micro USB       üí∏       MICRO_USB_CABLE.pdf           Componentes TUSISTEMITA                  PCB       Archivos fuente                       Placa trasera para montaje A01 para caja de 158x90x60mm       A01                 Tarjeta breakout C11 con salida a terminales de tornillos para Rpi Pico       C11           Software                  Software       Archivos fuente                       Firmware       PEDAL_USB_RPI_PICO           Componentes opcionales:                  Componente       Consigue el tuyo!       Hoja de caracteristicas                       Juego de 3 brocas escalonadas 3-20 mm + centropunto       üí∏       3_pc_set_3-20mm_drill_bit_incremental_center_punch.pdf                 Broca escalonada de 8 pasos 10-45 mm       üí∏       8_steps_10-45mm_incremental_drill_bit.pdf          ","categories": ["espanol"],
        "tags": ["AN002","RPI PICO","CIRCUITPYTHON"],
        "url": "https://galopago.github.io/espanol/pedal-usb-basado-en-rpi-pico/",
        "teaser": "https://galopago.github.io/assets/images/USB_PEDAL_RPI_PICO_TEASER.jpg"
      },{
        "title": "USB Pedal based on Rpi Pico",
        "excerpt":"USB pedals (or any other momentary switches) who emulates keyboard keypress or combination of keys. Handy to use with video edition software to pause/play without moving the hands away from the keyboard or mouse, it can also be used by videoconferencing software to mute quickly. There‚Äôs no need for special application to download initial firmware nor for keys setup (only a simple text editor needed). Works with almost any operating system, even with android devices using an OTG USB adapter.    \t   \tUSB Pedal circuit installed in a robust enclosure   Key component: Rpi Pico.   Concept:   A lot of USB programmable pedals on the market need to install an application for configuration. Usually this app is only for Windows and came poorly translated (if translated at all). This is a pitfall for Linux or Mac users, who have only two options: To install a Windows virtual machine or ask a favor to a Windows user for pedal setup.   Here come to the rescue Raspberry Pi Pico, for two big reasons: USB native interface, so no programmer or additional hardware needed for firmware download and the most important: CircuitPython support. Programming could be ‚Äúon the fly‚Äù without compiling-and-download during the debug phase. So Rpi Pico is the best candidate for a DIY pedal.   Another additional advantage over commercial USB pedals, the pedal itself can be replaced for a more robust one, without touching the circuit. Another kind of switches could be used, so operation with different parts of the body is possible. The amount of switches to be installed is only limited by Rpi Pico GPIO pins and the space available on the enclosure.   The circuit is built using TUSISTEMITA hardware prototyping system, which provides different kinds of prebuilt modules which allows to build an electronic project without soldering, but making it very robust and expandable. All the parts are enclosed in a dustproof and waterproof IP65 box. This enclosure gives an ‚Äúindustrial look‚Äù to the project and also adds mechanical strength to withstand abuses. The external electrical connections (pedals, and USB) were fitted with IP accessories to provide a good seal.   Key features:      Developed using CircuitPython, friendly and easy to learn   Compatible with the most common operating systems   No need to install apps for initial firmware download   Key configuration done in a text file   Splash resistant and shockproof   Detachable and replaceable pedals   Built using hardware prototyping system   Powered by USB, no additional power source needed   The hardware is pretty simple, only requires a Rpi Pico and switches connected between GPIO and ground. Internal pull-up resistors used. Power and data via USB cable    \t   \tSimplified block diagram   What is CircuitPython?:  In Adafruit Industres words, makers of CircuitPython:     CircuitPython is a programming language designed to simplify experimenting and learning to program on low-cost microcontroller boards. It makes getting started easier than ever with no upfront desktop downloads needed. Once you get your board set up, open any text editor, and get started editing code. It‚Äôs that simple.    Other reasons to use CircuitPython include:      You want to get up and running quickly. Create a file, edit your code, save the file, and it runs immediately. There is no compiling, no downloading and no uploading needed.   You‚Äôre new to programming. CircuitPython is designed with education in mind. It‚Äôs easy to start learning how to program and you get immediate feedback from the board.   Easily update your code. Since your code lives on the disk drive, you can edit it whenever you like, you can also keep multiple files around for easy experimentation.   The serial console and REPL. These allow for live feedback from your code and interactive programming.   File storage. The internal storage for CircuitPython makes it great for data-logging, playing audio clips, and otherwise interacting with files.   Strong hardware support. There are many libraries and drivers for sensors, breakout boards and other external components.   It‚Äôs Python! Python is the fastest-growing programming language. It‚Äôs taught in schools and universities. CircuitPython is almost-completely compatible with Python. It simply adds hardware support.   Software:   Sample application presented here is composed of two tasks: Initialize GPIO according to the configuration file and then runs an endless loop verifying for switch closing to send its respective keycode. Software debouncing function was used to avoid false key press. Rpi Pico onboard LED lights when whatever configured switch closes.   The configuration file structure is very simple. First line GPIOS to use, second line keycode to send, and third line modifier keycode (I.E SHIFT, CONTROL, ALT). If during initialization the config file isn‚Äôt found, the program will assume some default values. More GPIOS can be added to the config file, so 3, 4 or mode pedals could be plugged.   Circuit assembly:   The circuit was built using components of TUSISTEMITA, like enclosure backplate, and Rpi Pico screw terminal breakboard.   Once the app is downloaded for the first time, and electrical connections verified, the backplate could be attached to the enclosure hassle free. Just unplug USB cable and debug switches‚Äô screw terminals, screw backplate to enclosure and reconnect cables again.    \t   \t   \t   \tDebug, wiring and assembly.   USB printer connector (Type B) was chosen because is very robust and intuitive. This specific connector is designed for panel mounting and sports 4 metal pins (VCC,USB+,USB-,GND) that must be soldered to a Micro USB extension cable to plug to the Rpi Pico. Pedals use circular aviation connectors.    \t   \t   \t   \tConnectors for computer and pedals   Once the enclosure is closed, firmware updates could be done modifying the CircuitPython file, or via interactive environment. For a CircuitPython re-installation or Rpi Pico ‚Äúformat‚Äù, the enclosure must be open to access bootsel button.   Bill of materials                  Component       Get yours!       Datasheet                       M2.6 self-tapping B-type screw       üí∏       M2.6x5-6-8-12mm.pdf                 2:1 Heatshrink tube multiple colors       üí∏       2_1_heatshrink_tube_colors.pdf                 115x90x55 mm enclosure box       üí∏       KH-F3.pdf                 Raspberry Pi Pico       üí∏       pico-datasheet.pdf                 USB Type B IP68 panel connector       üí∏       USB_TYPE_B_PANEL_MOUNT_CONNECTOR.pdf                 4 pin aviation connector       üí∏       CIRCULAR_AVIATION_PANEL_CONNECTOR.pdf                 Metal electric foot switch       üí∏       METAL_MOMENTARY_ELECTRIC_FOOT_SWITCH.pdf                 USB printer cable A type       üí∏       USB_PRINTER_CABLE.pdf                 Micro USB cable       üí∏       MICRO_USB_CABLE.pdf           TUSISTEMITA blocks                  PCB       Source file                       A01 Backplate for 158x90x60mm enclosure       A01                 C11 screw terminal breakout board for Rpi Pico       C11           Software                  Software       Source file                       Firmware       PEDAL_USB_RPI_PICO           Optional components:                  Component       Get yours!       Datasheet                       3 pc step drill bit 3-20 mm + centerpunch       üí∏       3_pc_set_3-20mm_drill_bit_incremental_center_punch.pdf                 8 Step drill bit 10-45 mm       üí∏       8_steps_10-45mm_incremental_drill_bit.pdf          ","categories": ["english"],
        "tags": ["AN002","RPI PICO","CIRCUITPYTHON"],
        "url": "https://galopago.github.io/english/usb-pedal-rpi-pico-based/",
        "teaser": "https://galopago.github.io/assets/images/USB_PEDAL_RPI_PICO_TEASER.jpg"
      },{
        "title": "Halloween talking clock based on Rpi Pico",
        "excerpt":"Halloween talking clock that plays sounds every O‚Äôclock hour. Only a few external components (easy to source and solder) needed. The single side board could be manufactured at home. Very customizable project than involves multiple knowledge areas (STEAM): Electronics, programming, woodworking, arts, etc.    \t   \tCustomized clock hanging on a wall   Key component: Quartz clock movement with trigger   Concept:   A lot of musical wall clocks on the market lacks the possibility of change original sounds. A clock with that capability can be built with an embedded system. But which one to choose? Raspberry Pi Pico was chosen for the 3 following reasons:      There‚Äôs no need to install software for initial firmware download   Onboard memory 2 MegaBytes of flash can store some amount of sounds without requiring external memory   Can be powered by 2xAA batteries without additional components   Rpi Pico draws about 1.6 mA in it‚Äôs lowest power mode (deep sleep). Seems not much, but is too high for a battery powered circuit, because they will exhaust in around two months. For that reason an external power circuit that can shut off the board completely was added. After that, power consumption lowered to 70 uA, so batteries will last for a year.   The Rpi Pico acts as sound storage and player. To show the time and generate an O‚Äôclock signal, a quartz clock movement with trigger was used. Combining these 2 elements a talking sound clock was born   Key features:      Two versions of the (almost) same application: One developed in CircuitPython and the other in the C/C++ SDK.   Compatible with the most common operating systems.   No need to install apps for initial firmware download   There‚Äôs no need to recompile code (in the app developed in CircuitPython) to change sounds   Up to 3 years in standby mode using a pair of AA batteries.   Easy to source, and solder components.    \t   \tSimplified diagram of the power circuit   Software:   Right after power on, Rpi Pico puts a low level on the GPIO that is wired to the power circuit to keep it powered, then decides which file should be played, and after the sound finishes, a high level is put on the GPIO powering off the Pico. Additionally a light sensor is read to not play sound when is dark (night).   Sound files are played sequentially, one by one on each power on. A pointer to the next file is stored in nonvolatile memory, be carefully modifying the program to keep writing at a minimum.   PECULIARITIES OF THE SDK C/C++ VERSION:   Sounds to be played must be converted first to WAV format 16 bit mono @ 44100 Hz, then converted to C arrays[] before compiling. The application uses a PWM via digital output and interrupts to play sounds.   The program execution starts almost immediately after power on. The main disadvantage of the application for now, it only supports .WAV files which are big, and cannot be changed without recompiling code   PECULIARITIES OF THE CIRCUITPYTHON VERSION:   Sounds to be played must be converted to MP3 mono format, The app uses audiomp3 and audiopwmio modules to output audio out of a digital pin (PWM). These files are stored in the filesystem provided by CP, so modifying them is straightforward, just drag and drop.   MP3 files can store about 10 more sound time than WAV for the same file size, however CircuitPython runtime execution takes more than a second after power on, so probably it won‚Äôt be a good thing for any kind of final application   Hardware:  External components are part of one of the three different functionalities:           On/Off : The circuit is made up by a MOSFET, Drain terminal connected to 3V3_EN and the Source terminal connected to GND. Connected to the gate are 2 elements: A capacitor to ground, and a resistor to V+. The circuit works in the following way:                       Step 1: Capacitor is fully charged, turning on the MOSFET and tying 3V3_EN to ground totally powering off Rpi Pico board                        Step 2: Capacitor is quickly discharged by the brief closure of the contacts of the clock movement, turning off the MOSFET, and powering on the Rpi Pico. The first thing to do after power up, is keeping the capacitor discharged with the aid of a GPIO output in low level.                        Step 3: While sound is played, low level on the GPIO is kept. Once sound finishes, GPIO output turned high level, so MOSFET turns on again, powering off the Rpi Pico until the next switch closure                        Audio amplifier: Single-stage, single NPN transistor powers a small 8 Ohm speaker. There is also an input RC low pass filter to smooth noise due to the PWM output.            Day/night detection: Visible light sensor to avoid playing sounds at night. Connected to an ADC pin       Board assembly:   Rpi Pico, speaker, light sensor, and clock contacts could be soldered directly to the PCB to get a very small height profile, or add pin headers and female sockets for a more flexible option.   The single sided board can be etched at home. There are some free gpio pads for experimentation and also mounting holes near the corners    \t   \t   \t   \tHome etched board, direct soldering example and finished with connector headers.   To build the wall clock, choose a plate or disk made of plastic or wood, with enough diameter to hide the clock movement and the sound board. Fix all electronic components and then decorative accessories like LED lights. Finish it with the paint work    \t   \t   \t   \t   \tclock movement with external contacts, decorative elements, finished back and finished front   For hour adjustment, remove all batteries and clock hands (hour, minute, second). Slowly turn clock adjustment knob until a ‚Äúclick‚Äù sound is heard. Put all clock hands pointing to 12 O‚Äôclock. Put the batteries. Sounds can be shifted pressing the momentary push button switch on the board.   Bill of materials                  Component       Get yours!       Datasheet                       Female header 2.54mm       shop now       FHA3-S1XX.pdf                 Male pin header 2.54mm       shop now       PHA1-S3XX.pdf                 1/4W 1% TH Resistors       shop now       MGR-SERIES.pdf                 Push button 6x6mm       shop now       TS-1301.pdf                 Raspberry Pi Pico       shop now       pico-datasheet.pdf                 2xAA battery holder for PCB       shop now       Comfortable_Catalog.pdf                 8 Ohm speaker 29 mm 0.25W       shop now       DXP29W-A.pdf                 MOSFET 2N7000       shop now       NDS7002A-D.pdf                 NPN BIPOLAR TRANSISTOR 2N2222A       shop now       P2N2222A-D.pdf                 TH Radial Electrolytic Capacitor       shop now       TS13DE-CD110X.pdf                 TH Ceramic Disc Capacitor       shop now       TS15.pdf                 Quartz clock movement with trigger       shop now       12888SE_TRIGGER_CLOCK_MOVEMENT.pdf                 Wall Clock hooks DIY       shop now       wall_clock_hook.pdf                 TEPT5700 visible light photodiode       shop now       tept5700.pdf                 LED Copper Wire with battery box       shop now       LED_Copper_Wire_Battery_Box.pdf           Circuit board                  PCB       Source files                       Sound board (hardware directory)       SINSONTE           Software                  Software       Source files                       Firmware CircuitPython &amp; SDK C/C++ (software folder)       SINSONTE           Optional components:                  Component       Get yours!       Datasheet                       3 pc step drill bit 3-20 mm + centerpunch       shop now       3_pc_set_3-20mm_drill_bit_incremental_center_punch.pdf          ","categories": ["english"],
        "tags": ["AN003","RPI PICO","C/C++ SDK","CIRCUITPHYTON"],
        "url": "https://galopago.github.io/english/halloween-talking-clock-based-on-rpi-pico/",
        "teaser": "https://galopago.github.io/assets/images/HALLOWEEN_TALKING_CLOCK_TEASER.jpg"
      },{
        "title": "Reloj sonoro para halloween basado en Rpi Pico",
        "excerpt":"Reloj con sonidos de halloween que son reproducidos cada hora en punto. Requiere pocos componentes externos, los cuales son faciles de conseguir y de soldar. La tarjeta de circuito impreso es de una sola cara y puede hacerse de forma casera. Proyecto bastante personalizable y que involucra multiples areas (STEAM):Montaje electronico, programacion, carpinteria, arte, manualidades, etc.    \t   \tReloj personalizado instalado en la pared   Componente clave: Maquinaria para reloj de pared con contacto externo   El concepto:   La gran mayoria de los relojes de pared musicales que se encuentran en el mercado vienen con sonidos que no pueden ser cambiados ni modificados. Esto podria solucionarse con infinidad de microcontroladores y/o sistemas embebidos que hay actualmente en el mercado. Como la idea del proyecto es hacer que sea lo mas facil posible modificar los sonidos, el proyecto se decanto por el Raspberry Pi Pico por 3 razones principalmente:      No se requiere instalar ninguna aplicacion ni driver para descargar el firmware.   La tarjeta cuenta con 2 MegaBytes de memoria flash, por lo tanto se podrian grabar algunos sonidos en dicha memoria sin necesitar hardware adicional como memorias SPI o Micro SD.   La alimentacion se puede hacer mediante dos baterias AA directamente sin requerir componentes adicionales!   La tarjeta Raspberry Pi Pico, tiene un consumo aproximado de 1.6 mA en su rango mas bajo (en modo sue√±o profundo). Aunque parece poco, es demasiado alto para un circuito alimentado con baterias AA, pues estas se descargarian aproximadamente en 2 meses. Por esta razon fue necesario agregar un circuito externo que apagara totalmente la tarjeta, cayendo el consumo a 70 uA aproximadamente, lo cual le otorgaria una autonomia de un a√±o mas o menos.   La funcionalidad principal del Raspberry Pi Pico es almacenar archivos de sonido y reproducirlos. Para mostrar las horas y generar una se√±al cada hora en punto, se usa una maquinaria de reloj de pared que tiene una salida de contacto. Combinando estos 2 elementos se obtiene el reloj que reproduce sonidos cada hora en punto!   Principales Caracteristicas:      Se han desarrollado 2 versiones que hacen practicamente lo mismo: una en CircuitPython y la otra en el SDK de C/C++.   Compatible con los sistemas operativos mas conocidos.   No se requiere instalar ninguna aplicacion para descargar el Firmware inicial.   La modificacion de los sonidos (en la version CircuitPython) no requiere recompilar codigo.   Hasta 3 a√±os de duracion de las baterias AA en modo espera.   Componentes muy faciles de conseguir y ensamblar.    \t   \tDiagrama simplificado del sistema encendido/apagado   El programa:   Al encenderse el Rpi Pico lo primero que este hace es poner en nivel bajo el GPIO que esta conectado al circuito de encendido para mantenerlo enganchado, luego determina cual debe ser el archivo a reproducir y al final de la reproducion pone el GPIO del circuito de encendido en nivel alto con lo que hace que el sistema se apague totalmente. Adicionalmente se cuenta con un sensor de luz conectado a una entrada analoga para determinar si es de noche y no reproducir sonidos.   Los archivos se reproducen en forma secuencial, uno a uno con cada encendido de la tarjeta, y para poder guardar la informacion del proximo archivo a reproducir se usa la memoria no volatil, asi que se debera ser cuidadoso al modificar el programa para evitar desgastes acelerados!   PARTICULARIDADES DE LA VERSION EN SDK C/C++:   Los sonidos a reproducir deberan ser convertidos a formato .WAV 16 bit monofonicos a 44100 Hz. Una vez hecho esto, se deberan procesar para generar archivos .h que contendran arrays[] de C e incluirlos en el codigo antes de compilar. El programa usa una salida digital mediante PWM e interrupciones para la reproduccion de los sonidos.   La principal virtud es que la ejecucion es inmediata al encender la tarjeta. La principal desventaja es que por ahora solo reproduce archivos .WAV que consumen bastante memoria, y para cambiarlos se requiere recompilar el programa.   PARTICULARIDADES DE LA VERSION EN CIRCUITPYTHON:   Los sonidos a reproducir deberan ser convertidos a formato .MP3 monofonicos. El programa usa los modulos audiopwmio y audiomp3 para la reproduccion de los archivos, que son leidos desde el sistema de archivos que viene incorporado. simplemente descargarlos al Rpi Pico y listo!   La principal virtud es la facilidad para cambiar los archivos de sonido: solo hay que arrastrar los nuevos archivos y reemplazar los actuales, ademas por ser en formato MP3 se puede almacenar unas 10 veces mas tiempo de sonido que en formato WAV. La principal desventaja es que la tarjeta toma algo mas de un segundo en ejecutar el codigo despues de encenderse, esto podria ser inadmisible en algunas aplicaciones.   El circuito:  Los componentes externos adicionales al Rpi Pico componen tres diferentes funcionalidades:           Encendido/Apagado: El circuito esta compuesto principalmente por un MOSFET, el Drain se conecta a la se√±al 3V3_EN y el source a GND. En la compuerta hay 2 elementos un capacitor conectado a tierra y una resistencia conectada a V+. Este circuito funciona en 3 pasos que se repiten ciclicamente:                       Paso 1: El condensador esta totalmente cargado, haciendo que el MOSFET entre en conduccion, llevando la se√±al 3V3_EN a tierra y apagando completamente la tarjeta.                        Paso 2: El condensador se descarga rapidamente mediante un pulsador o se√±al de contacto proveniente de la maquinaria del reloj, haciendo que momentaneamente el MOSFET entre en estado de no conduccion y se encienda la tarjeta. Al encenderse la tarjeta, lo primero que hace el programa es mantener dicho condensador descargado mediante un GPIO que pone en nivel bajo                        paso 3: La tarjeta mantendra el nivel bajo del GPIO durante la ejecucion del sonido. Al finalizar pondra dicho GPIO en nivel alto, haciendo que el condensador se cargue rapidamente y que el MOSFET entre en conducion y se apague la tarjeta. La tarjeta quedara apagada totalmente hasta una nueva pulsacion.                        Amplificador de audio: Consta de una sola etapa, mediante un unico transistor NPN conectado a una bocina de 8 Ohm. Posee una etapa previa de filtrado mediante condensador y resistencia, para evitar posible ruido de la salida digital PWM            Deteccion dia/noche: Sensor de luz para determinar si los sonidos deben reproducirse ( en el dia ) o no se deben reproducir ( noche ), esto para evitar ruidos molestor a la madrugada!       Ensamblaje:   El Rpi Pico puede ser soldado directamente a la tarjeta de circuito impreso, con lo cual se obtendra un conjunto de poca altura, o se podran soldar pines tipo header al Rpi Pico y conector hembra en la PCB para lograr un sistema flexible donde se puede extraer el Pico a voluntad. Todos los demas componentes no representan mucho problema, pues son de montaje Thru-hole. Finalmente la bocina, el sensor de luz y el interruptor de reloj podrian montarse mediante conectores para poder removerlos a voluntad, o directamente los cables al PCB para mayor ahorro de espacio.   El dise√±o de la tarjeta es de una sola capa y puede hacerse de forma casera en caso de ser necesario. Se han dejado pads libres para conexion a la mayoria de los GPIO del Rpi Pico, con lo cual se puede expandir sin mucho esfuerzo.   La tarjeta cuenta con 4 orificios para montaje, donde puede ser sujetada a la parte trasera del reloj de pared    \t   \t   \t   \tTarjeta casera, ejemplo de montaje directo y finalizada con conectores.   Para la construccion del reloj se debe escoger un disco, o plato, que puede ser de madera o plastico lo suficientemente grande para que pueda ubicarse la maquinaria del reloj y la tarjeta reproductora de los sonidos. Se debera realizar la fijacion de los elementos electronicos, seguido a esto se pueden agregar algunos accesorios como luces led y finalmente se realiza el trabajo artistico.    \t   \t   \t   \t   \tMecanismo con salida externa, elementos decorativos, finalizado por atras y finalizado de frente   Para ajustar la hora, se deben retirar las baterias y todas las manecillas (horario, minutero y segundero). Girar muy lentamente la perilla de ajuste del mecanismo de reloj hasta escuchar un ‚Äúclick‚Äù. En ese momento poner todas las manecillas apuntando a las 12. Poner las baterias. Al presionar el interruptor pulsador de la tarjeta se puede ‚Äúavanzar‚Äù sonidos una hora con cada pulsacion.   Listado de materiales                  Componente       Consigue el tuyo!       Hoja de caracteristicas                       Conector de hilera de pines hembra 2.54mm       lo quiero comprar       FHA3-S1XX.pdf                 Conector de hilera de pines macho 2.54mm       lo quiero comprar       PHA1-S3XX.pdf                 Resistencias TH 1/4W 1%       lo quiero comprar       MGR-SERIES.pdf                 Interruptor momentaneo pulsador 6x6mm       lo quiero comprar       TS-1301.pdf                 Raspberry Pi Pico       lo quiero comprar       pico-datasheet.pdf                 Soporte para bateria AA para montaje en PCB       lo quiero comprar       Comfortable_Catalog.pdf                 Bocina 8 Ohm 29 mm 0.25W       lo quiero comprar       DXP29W-A.pdf                 MOSFET 2N7000       lo quiero comprar       NDS7002A-D.pdf                 Transistor bipolar NPN 2N2222A       lo quiero comprar       P2N2222A-D.pdf                 Capacitor TH electrolitico       lo quiero comprar       TS13DE-CD110X.pdf                 Capacitor TH Ceramico de disco       lo quiero comprar       TS15.pdf                 Maquinaria de reloj de pared con contacto externa       lo quiero comprar       12888SE_TRIGGER_CLOCK_MOVEMENT.pdf                 Gancho para colgar reloj en pared       lo quiero comprar       wall_clock_hook.pdf                 Fotodiodo de luz visible TEPT5700       lo quiero comprar       tept5700.pdf                 Tira de alambre coblre con LED y caja de bateria       lo quiero comprar       LED_Copper_Wire_Battery_Box.pdf           Circuito impreso                  PCB       Archivos fuente                       Tarjeta de reproduccion de sonido (carpeta hardware)       SINSONTE           Software                  Software       Archivos fuente                       Firmware en CircuitPython &amp; SDK C/C++ (carpeta software)       SINSONTE           Componentes opcionales:                  Componente       Consigue el tuyo!       Hoja de caracteristicas                       Juego de 3 brocas escalonadas 3-20 mm + centropunto       compralo aqui       3_pc_set_3-20mm_drill_bit_incremental_center_punch.pdf          ","categories": ["espanol"],
        "tags": ["AN003","RPI PICO","C/C++ SDK","CIRCUITPHYTON"],
        "url": "https://galopago.github.io/espanol/reloj-sonidos-halloween-basado-en-rpi-pico/",
        "teaser": "https://galopago.github.io/assets/images/HALLOWEEN_TALKING_CLOCK_TEASER.jpg"
      }]
